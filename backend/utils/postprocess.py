# backend/utils/postprocess.py
import re
import subprocess
from pathlib import Path
from typing import Tuple, Optional

# ----------------------------------------------------------------------
# 1️⃣  Strip des fences Markdown
# ----------------------------------------------------------------------
def strip_fences(code: str) -> str:
    """
    Supprime les fences Markdown éventuels autour du code.
    Gère ```python, ```bash, ```julia, etc.
    """
    # Recherche du premier bloc de fence et du dernier
    fence_pattern = r"^```(?:[a-zA-Z0-9]*)?\s*$"
    lines = code.splitlines()
    # Retirer les fences en tête et queue
    while lines and re.match(fence_pattern, lines[0]):
        lines.pop(0)
    while lines and re.match(fence_pattern, lines[-1]):
        lines.pop(-1)
    return "\n".join(lines).strip()


# ----------------------------------------------------------------------
# 2️⃣  Normalisation des indentations (tabs → 4 spaces)
# ----------------------------------------------------------------------
def normalize_indentation(code: str) -> str:
    return code.replace("\t", "    ")


# ----------------------------------------------------------------------
# 3️⃣  Vérification de syntaxe (Python uniquement pour l’exemple)
# ----------------------------------------------------------------------
def syntax_ok_python(code: str) -> Tuple[bool, Optional[str]]:
    """
    Retourne (True, None) si le code Python compile,
    sinon (False, message d’erreur).
    """
    try:
        compile(code, "<generated>", "exec")
        return True, None
    except SyntaxError as exc:
        return False, f"{exc.msg} (line {exc.lineno})"


# ----------------------------------------------------------------------
# 4️⃣  Formatage avec Black (Python) – fallback si Black absent
# ----------------------------------------------------------------------
def format_python_black(code: str) -> str:
    try:
        import black
        mode = black.FileMode()
        return black.format_str(code, mode=mode)
    except Exception:
        # Black non installé ou erreur – on renvoie le code brut
        return code


# ----------------------------------------------------------------------
# 5️⃣  Détection de code dangereux (liste blanche configurable)
# ----------------------------------------------------------------------
DANGEROUS_PATTERNS = [
    r"\beval\s*\(",
    r"\bexec\s*\(",
    r"\bos\.system\s*\(",
    r"\bsubprocess\.Popen\s*\(",
    r"\bsubprocess\.call\s*\(",
    r"\bsubprocess\.run\s*\(",
]

def contains_dangerous_code(code: str) -> bool:
    """Retourne True si l’un des patterns dangereux est trouvé."""
    for pat in DANGEROUS_PATTERNS:
        if re.search(pat, code):
            return True
    return False


# ----------------------------------------------------------------------
# 6️⃣  Header de provenance
# ----------------------------------------------------------------------
def add_provenance_header(code: str) -> str:
    header = "# Generated by Chloe‑Code (LLM) – 2026-01-17\n"
    return header + code


# ----------------------------------------------------------------------
# 7️⃣  Fonction principale – postprocess_code
# ----------------------------------------------------------------------
def postprocess_code(
    raw_code: str,
    language: str,
    block_dangerous: bool = False,
) -> Tuple[str, Optional[str]]:
    """
    Applique toutes les étapes de post‑processing.
    Retourne (code_final, warning_message).  warning_message est None si tout va bien.
    """
    # 1. Strip fences
    code = strip_fences(raw_code)

    # 2. Normalisation indentation
    code = normalize_indentation(code)

    # 3. Détection de code dangereux
    if block_dangerous and contains_dangerous_code(code):
        return "", "Code dangereux détecté et bloqué (eval/exec/os.system/etc.)"

    # 4. Formatage / validation selon le langage
    warning = None
    if language == "python":
        ok, err = syntax_ok_python(code)
        if not ok:
            warning = f"Syntax error : {err}"
        else:
            code = format_python_black(code)
    # TODO : ajouter les formatters pour R, Julia, JS/TS, Bash, LaTeX, SQL
    # (pour le prototype on laisse le code tel quel)

    # 5. Header de provenance
    code = add_provenance_header(code)

    return code, warning